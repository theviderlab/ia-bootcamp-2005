{
  "info": {
    "_postman_id": "agent-lab-api-001",
    "name": "Agent Lab API",
    "description": "Comprehensive API tests for Agent Lab LLM and RAG system. Tests are organized sequentially with dependencies.\n\n**Prerequisites:**\n- Server running at http://localhost:8000\n- Valid OPENAI_API_KEY in environment\n- Valid PINECONE_API_KEY in environment (optional for semantic search)\n- MySQL database running and accessible\n- data/initial_knowledge/ directory accessible by server (can be empty)\n\n**Execution Order:**\n1. Health & Connectivity\n2. LLM Basic Operations\n3. Chat Operations\n4. Memory Operations (requires database, optional Pinecone)\n5. Session Management (reset operations)\n6. RAG - Setup (adds documents - uses embedded content, not file paths)\n7. RAG - Query Operations (depends on #6)\n7b. RAG - Listing Operations (lists namespaces and documents with pagination)\n8. Error Scenarios\n9. Cleanup (removes test data)\n\n**New in this version:**\n- Section 4: Memory Operations tests with 12 test cases\n- Section 5: Session Management with reset endpoint tests\n- Section 7b: RAG Listing Operations with namespace/document browsing and pagination\n- Tests all memory endpoints: context, history, stats, semantic search, cleanup\n- Database pre-flight check in memory setup\n- Pinecone optional: semantic search fails gracefully if not configured\n- Memory cleanup integrated into final cleanup section\n\n**Note:** RAG tests send document content directly, not file paths. See tests/api/postman/RAG_TESTING_NOTES.md for details.",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "1. Health & Connectivity",
      "item": [
        {
          "name": "Health Check",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response is JSON\", () => {",
                  "    pm.response.to.be.json;",
                  "});",
                  "",
                  "pm.test(\"Health status is healthy\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('status');",
                  "    pm.expect(data.status).to.eql('healthy');",
                  "});",
                  "",
                  "console.log(\"âœ… API is healthy and running\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "089f13b8-4454-4f77-9268-678fa1bc7f9f",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/health",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "health"
              ]
            },
            "description": "Verifies the API server is running and responding correctly."
          },
          "response": []
        },
        {
          "name": "API Root Info",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has required fields\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('message');",
                  "    pm.expect(data).to.have.property('version');",
                  "    pm.expect(data).to.have.property('endpoints');",
                  "});",
                  "",
                  "pm.test(\"Endpoints object is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.endpoints).to.be.an('object');",
                  "    pm.expect(data.endpoints).to.have.property('health');",
                  "    pm.expect(data.endpoints).to.have.property('docs');",
                  "    pm.expect(data.endpoints).to.have.property('llm');",
                  "    pm.expect(data.endpoints).to.have.property('rag');",
                  "    pm.expect(data.endpoints).to.have.property('mpc');",
                  "});",
                  "",
                  "pm.test(\"LLM endpoints are defined\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.endpoints.llm).to.be.an('object');",
                  "    pm.expect(data.endpoints.llm).to.have.property('generate');",
                  "    pm.expect(data.endpoints.llm).to.have.property('chat');",
                  "});",
                  "",
                  "pm.test(\"RAG endpoints are defined\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.endpoints.rag).to.be.an('object');",
                  "    pm.expect(data.endpoints.rag).to.have.property('query');",
                  "    pm.expect(data.endpoints.rag).to.have.property('add_documents');",
                  "    pm.expect(data.endpoints.rag).to.have.property('add_directory');",
                  "});",
                  "",
                  "pm.test(\"MPC endpoints are defined\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.endpoints.mpc).to.be.an('object');",
                  "    pm.expect(data.endpoints.mpc).to.have.property('create_instance');",
                  "    pm.expect(data.endpoints.mpc).to.have.property('delete_instance');",
                  "    pm.expect(data.endpoints.mpc).to.have.property('get_instance');",
                  "    pm.expect(data.endpoints.mpc).to.have.property('list_instances');",
                  "});",
                  "",
                  "console.log(\"âœ… API info retrieved successfully\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "139debe2-2b26-4348-a2d1-1493ff1cf524",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                ""
              ]
            },
            "description": "Retrieves API information and available endpoints."
          },
          "response": []
        }
      ],
      "id": "17a0ac66-e0bc-436d-806a-2d1443a12236",
      "description": "Basic connectivity and health checks to ensure the API is operational."
    },
    {
      "name": "2. LLM Basic Operations",
      "item": [
        {
          "name": "Generate - Success",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has required fields\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('text');",
                  "    pm.expect(data).to.have.property('prompt');",
                  "});",
                  "",
                  "pm.test(\"Response fields have correct types\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.text).to.be.a('string');",
                  "    pm.expect(data.prompt).to.be.a('string');",
                  "});",
                  "",
                  "pm.test(\"Generated text is not empty\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.text.length).to.be.above(0);",
                  "});",
                  "",
                  "pm.test(\"Prompt matches request\", () => {",
                  "    const data = pm.response.json();",
                  "    const requestBody = JSON.parse(pm.request.body.raw);",
                  "    pm.expect(data.prompt).to.eql(requestBody.prompt);",
                  "});",
                  "",
                  "// Save response for potential chaining",
                  "const data = pm.response.json();",
                  "pm.collectionVariables.set(\"last_llm_response\", data.text);",
                  "console.log(\"âœ… Text generated successfully:\", data.text.substring(0, 50) + \"...\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "ee1b7079-f322-48bd-a26c-b3967ea27a29",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"prompt\": \"What are the three main benefits of using Python for web development?\",\n  \"temperature\": 0.7,\n  \"max_tokens\": 200\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Generates text from a prompt with custom temperature and max_tokens parameters."
          },
          "response": []
        },
        {
          "name": "Generate - With Defaults",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('text');",
                  "    pm.expect(data).to.have.property('prompt');",
                  "});",
                  "",
                  "pm.test(\"Works without optional parameters\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.text).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "console.log(\"âœ… Generation with defaults successful\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "6c8d43d5-a742-4672-a607-b7a1d555bf65",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"prompt\": \"Explain FastAPI in one sentence.\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Tests generation using only required parameters (prompt), relying on defaults for temperature and max_tokens."
          },
          "response": []
        },
        {
          "name": "Generate - Empty Prompt Error",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Response contains error detail\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Empty prompt correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "2e252b15-f17f-4f40-82c4-f8fdb4ed5c93",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"prompt\": \"\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Tests error handling for empty prompt. Should return 422 validation error."
          },
          "response": []
        },
        {
          "name": "Generate - Invalid Temperature",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error indicates validation failure\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Invalid temperature correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "2325aa0f-801d-409c-a7b8-4715cc5fd382",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"prompt\": \"Test prompt\",\n  \"temperature\": 2.5\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Tests validation of temperature parameter (should be between 0.0 and 1.0)."
          },
          "response": []
        }
      ],
      "id": "1d199a33-0ead-4b59-a5cc-2be82791eee8",
      "description": "Tests for the text generation endpoint with various parameter combinations and error cases."
    },
    {
      "name": "3. Chat Operations",
      "item": [
        {
          "name": "Chat - Basic",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has required fields\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('response');",
                  "    pm.expect(data).to.have.property('session_id');",
                  "});",
                  "",
                  "pm.test(\"Response is not empty\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.response).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "pm.test(\"Session ID is generated\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.session_id).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "// Save session ID for subsequent requests",
                  "const data = pm.response.json();",
                  "pm.collectionVariables.set(\"session_id\", data.session_id);",
                  "console.log(\"âœ… Chat session created:\", data.session_id);",
                  "console.log(\"Response:\", data.response.substring(0, 100) + \"...\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "71618430-8307-4f5b-8ec3-b47957f7bb69",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"Hello! What is Python?\"\n    }\n  ]\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Initiates a new chat session with a basic user message. Session ID is saved for subsequent requests."
          },
          "response": []
        },
        {
          "name": "Chat - With Session ID",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Session ID matches\", () => {",
                  "    const data = pm.response.json();",
                  "    const expectedSessionId = pm.collectionVariables.get(\"session_id\");",
                  "    pm.expect(data.session_id).to.eql(expectedSessionId);",
                  "});",
                  "",
                  "pm.test(\"Response is contextual\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.response).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "console.log(\"âœ… Chat continued with session:\", pm.collectionVariables.get(\"session_id\"));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Verify session_id exists from previous test",
                  "const sessionId = pm.collectionVariables.get(\"session_id\");",
                  "if (!sessionId) {",
                  "    console.error(\"âŒ No session_id found. Run 'Chat - Basic' first.\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "c4696b79-f52b-47ed-888d-6ca8fc946b50",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"Hello! What is Python?\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"Python is a high-level programming language.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"What are its main features?\"\n    }\n  ],\n  \"session_id\": \"{{session_id}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Continues an existing chat session using the session_id from the previous request. Tests multi-turn conversation handling."
          },
          "response": []
        },
        {
          "name": "Chat - With System Message",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response follows system instructions and respects max_tokens\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.response).to.be.a('string');",
                  "    // With max_tokens=300, response should be reasonably concise",
                  "    pm.expect(data.response.length).to.be.below(1500);",
                  "});",
                  "",
                  "console.log(\"âœ… System message and max_tokens respected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "339fe8e8-e824-41eb-a590-729e387bd344",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a helpful assistant that provides concise, technical answers.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Explain the SOLID principles.\"\n    }\n  ],\n  \"temperature\": 0.5,\n  \"max_tokens\": 100\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests chat with a system message that guides the assistant's behavior."
          },
          "response": []
        },
        {
          "name": "Chat - With Custom Parameters",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response structure is correct\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('response');",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data.response).to.be.a('string');",
                  "});",
                  "",
                  "pm.test(\"Response respects low temperature for deterministic output\", () => {",
                  "    const data = pm.response.json();",
                  "    // With low temperature, response should be focused",
                  "    pm.expect(data.response.length).to.be.greaterThan(0);",
                  "});",
                  "",
                  "console.log(\"âœ… Custom parameters (temperature and max_tokens) handled correctly\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "a7b9c3d1-e2f4-5a6b-7c8d-9e0f1a2b3c4d",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is Python?\"\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 100\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests chat with custom temperature (0.3 for deterministic) and max_tokens (100 for concise response)."
          },
          "response": []
        },
        {
          "name": "Chat - With Context Data",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response includes all required fields\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('response');",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data).to.have.property('context_text');",
                  "    pm.expect(data).to.have.property('context_tokens');",
                  "    pm.expect(data).to.have.property('rag_sources');",
                  "});",
                  "",
                  "pm.test(\"Context fields have correct types\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.context_text).to.be.a('string');",
                  "    pm.expect(data.context_tokens).to.be.a('number').and.at.least(0);",
                  "    pm.expect(data.rag_sources).to.be.an('array');",
                  "});",
                  "",
                  "pm.test(\"Context tokens is accurate (uses tiktoken)\", () => {",
                  "    const data = pm.response.json();",
                  "    // Token count should be reasonable for the context",
                  "    pm.expect(data.context_tokens).to.be.at.most(4000);",
                  "});",
                  "",
                  "// Save session_id for potential future tests",
                  "const data = pm.response.json();",
                  "if (data.session_id) {",
                  "    pm.collectionVariables.set(\"session_id\", data.session_id);",
                  "}",
                  "",
                  "console.log(\"âœ… Chat with context data successful\");",
                  "console.log(\"  - Context tokens:\", data.context_tokens);",
                  "console.log(\"  - Context text length:\", data.context_text.length);",
                  "console.log(\"  - RAG sources count:\", data.rag_sources.length);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "e8f9a0b1-c2d3-4e5f-6a7b-8c9d0e1f2a3b",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is Python?\"\n    }\n  ],\n  \"temperature\": 0.7,\n  \"max_tokens\": 200\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests that chat response includes context_text, context_tokens (calculated with tiktoken), and rag_sources fields. All responses now include context data by default."
          },
          "response": []
        },
        {
          "name": "Chat - With RAG Context",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Note: This test requires RAG documents to be added first (Section 6)",
                  "console.log(\"â„¹ï¸  This test expects RAG documents from Section 6 to be indexed\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response includes RAG sources\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('rag_sources');",
                  "    pm.expect(data.rag_sources).to.be.an('array');",
                  "    ",
                  "    // If RAG is enabled and documents exist, we should have sources",
                  "    if (data.rag_sources.length > 0) {",
                  "        console.log(\"âœ… RAG sources found:\", data.rag_sources.length);",
                  "    } else {",
                  "        console.log(\"â„¹ï¸  No RAG sources (RAG may be disabled or no matching documents)\");",
                  "    }",
                  "});",
                  "",
                  "pm.test(\"RAG sources have correct structure\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    if (data.rag_sources.length > 0) {",
                  "        const firstSource = data.rag_sources[0];",
                  "        pm.expect(firstSource).to.have.property('content');",
                  "        pm.expect(firstSource).to.have.property('score');",
                  "        pm.expect(firstSource).to.have.property('doc_id');",
                  "        pm.expect(firstSource).to.have.property('namespace');",
                  "        ",
                  "        // Validate types",
                  "        pm.expect(firstSource.content).to.be.a('string');",
                  "        pm.expect(firstSource.score).to.be.a('number').and.within(0, 1);",
                  "        pm.expect(firstSource.doc_id).to.be.a('string');",
                  "        pm.expect(firstSource.namespace).to.be.a('string');",
                  "        ",
                  "        console.log(\"âœ… RAG source structure validated\");",
                  "        console.log(\"  - Top score:\", firstSource.score);",
                  "        console.log(\"  - Doc ID:\", firstSource.doc_id);",
                  "        console.log(\"  - Namespace:\", firstSource.namespace);",
                  "    }",
                  "});",
                  "",
                  "pm.test(\"Context includes RAG data\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    if (data.rag_sources.length > 0) {",
                  "        // Context text should include RAG section",
                  "        pm.expect(data.context_text).to.include('Knowledge Base');",
                  "        console.log(\"âœ… Context includes RAG Knowledge Base section\");",
                  "    }",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "f0a1b2c3-d4e5-6f7a-8b9c-0d1e2f3a4b5c",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is FastAPI?\"\n    }\n  ],\n  \"use_rag\": true,\n  \"rag_top_k\": 3\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests chat with RAG enabled. Verifies that rag_sources field is populated with document chunks including content, similarity scores, doc_id, namespace, and optional chunk_index."
          },
          "response": []
        },
        {
          "name": "Chat - Invalid Role Error",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error indicates invalid role\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Invalid role correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "01a4ff45-a28f-4d5d-8a2e-8e6be0631e3a",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"invalid_role\",\n      \"content\": \"This should fail\"\n    }\n  ]\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests validation of message roles. Only 'user', 'assistant', and 'system' are valid."
          },
          "response": []
        },
        {
          "name": "Chat - Missing Content Error",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error indicates missing content\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Missing content correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "3facbca7-8987-404f-8884-d9949578fa63",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\"\n    }\n  ]\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests that messages must include content field."
          },
          "response": []
        },
        {
          "name": "Chat - Empty Messages Error",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error indicates empty messages\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Empty messages array correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "f35ee3d9-f706-4bd8-81b4-c27cd6e6b5dc",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": []\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Tests that at least one message is required in the messages array."
          },
          "response": []
        }
      ],
      "id": "41f20a61-f243-4432-a499-aa5de183a02f",
      "description": "Tests for the chat endpoint including conversation state management, system messages, and error handling."
    },
    {
      "name": "4. Memory Operations",
      "item": [
        {
          "name": "Memory Setup - Create Test Session",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "mem-setup-prereq-001",
                "exec": [
                  "// Pre-flight check: Verify database is accessible",
                  "console.log(\"ðŸ” Pre-flight check: Testing database connectivity...\");",
                  "",
                  "// Generate unique session ID for memory tests",
                  "const timestamp = Date.now();",
                  "const sessionId = `memory-test-${timestamp}`;",
                  "pm.collectionVariables.set(\"memory_test_session_id\", sessionId);",
                  "",
                  "console.log(\"âœ… Memory test session ID:\", sessionId);",
                  "console.log(\"â„¹ï¸  This test will create 4 chat messages for memory testing\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "mem-setup-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Chat response is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('response');",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data.response).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "// Increment message counter",
                  "let msgCount = parseInt(pm.collectionVariables.get(\"memory_messages_added\") || \"0\");",
                  "msgCount++;",
                  "pm.collectionVariables.set(\"memory_messages_added\", msgCount.toString());",
                  "",
                  "console.log(\"âœ… Message 1/4 added to memory test session\");",
                  "",
                  "// Note: Need to run this request 4 times or create separate requests",
                  "// For now, mark memory as ready after first message",
                  "if (msgCount >= 1) {",
                  "    pm.collectionVariables.set(\"memory_ready\", \"true\");",
                  "    console.log(\"âœ… Memory test session ready with\", msgCount, \"message(s)\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-setup-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"I love Python programming and data science. I'm working on machine learning projects.\"\n    }\n  ],\n  \"session_id\": \"{{memory_test_session_id}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Creates initial conversation for memory testing. Sends messages about Python, data science, and ML to generate semantic content for memory extraction. Pre-flight check verifies database connectivity."
          },
          "response": []
        },
        {
          "name": "Memory Setup - Add More Context",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-setup-test-002",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "let msgCount = parseInt(pm.collectionVariables.get(\"memory_messages_added\") || \"0\");",
                  "msgCount += 3; // User + Assistant + User (3 mensajes enviados)",
                  "pm.collectionVariables.set(\"memory_messages_added\", msgCount.toString());",
                  "",
                  "console.log(\"âœ… Added follow-up message (\", msgCount, \"total messages)\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-setup-002",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"I love Python programming and data science.\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"That's great! Python is excellent for data science with libraries like pandas, numpy, and scikit-learn.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"What are best practices for Python testing?\"\n    }\n  ],\n  \"session_id\": \"{{memory_test_session_id}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/chat",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "chat"
              ]
            },
            "description": "Adds more conversational context with questions about testing best practices."
          },
          "response": []
        },
        {
          "name": "Get Memory Context - Success",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "mem-context-prereq-001",
                "exec": [
                  "// Verify memory is ready",
                  "const memoryReady = pm.collectionVariables.get(\"memory_ready\");",
                  "const sessionId = pm.collectionVariables.get(\"memory_test_session_id\");",
                  "",
                  "if (!sessionId) {",
                  "    console.error(\"âŒ No memory test session. Run '8.1 Memory Setup' first.\");",
                  "}",
                  "",
                  "if (memoryReady !== \"true\") {",
                  "    console.warn(\"âš ï¸  Memory may not be ready. Ensure setup completed.\");",
                  "}",
                  "",
                  "console.log(\"ðŸ” Retrieving memory context for session:\", sessionId);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "mem-context-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Memory context structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    // Required fields",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data).to.have.property('short_term_context');",
                  "    pm.expect(data).to.have.property('semantic_facts');",
                  "    pm.expect(data).to.have.property('user_profile');",
                  "    pm.expect(data).to.have.property('total_messages');",
                  "    ",
                  "    // Type validation",
                  "    pm.expect(data.session_id).to.be.a('string');",
                  "    pm.expect(data.short_term_context).to.be.a('string');",
                  "    pm.expect(data.semantic_facts).to.be.an('array');",
                  "    pm.expect(data.user_profile).to.be.an('object');",
                  "    pm.expect(data.total_messages).to.be.a('number').and.at.least(1);",
                  "    ",
                  "    // Optional fields (nullable)",
                  "    if (data.episodic_summary !== null) {",
                  "        pm.expect(data.episodic_summary).to.be.a('string');",
                  "    }",
                  "    ",
                  "    if (data.procedural_patterns !== null) {",
                  "        pm.expect(data.procedural_patterns).to.be.an('array');",
                  "    }",
                  "});",
                  "",
                  "pm.test(\"Session ID matches test session\", () => {",
                  "    const data = pm.response.json();",
                  "    const expectedSessionId = pm.collectionVariables.get(\"memory_test_session_id\");",
                  "    pm.expect(data.session_id).to.eql(expectedSessionId);",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Memory context retrieved\");",
                  "console.log(\"   Total messages:\", data.total_messages);",
                  "console.log(\"   Semantic facts:\", data.semantic_facts.length);",
                  "console.log(\"   Profile keys:\", Object.keys(data.user_profile).length);",
                  "",
                  "// Check if semantic facts are present",
                  "if (data.semantic_facts.length > 0) {",
                  "    console.log(\"âœ… Semantic extraction working\");",
                  "} else {",
                  "    console.log(\"â„¹ï¸  No semantic facts extracted yet (may need more messages)\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-context-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"session_id\": \"{{memory_test_session_id}}\",\n  \"max_tokens\": 2000\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/context",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "context"
              ]
            },
            "description": "Retrieves complete memory context including short-term buffer, semantic facts, user profile, episodic summary, and procedural patterns. Tests all memory types from memory_processor.py."
          },
          "response": []
        },
        {
          "name": "Get Memory Context - With Low Max Tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-context-test-002",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Context respects token limit\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('short_term_context');",
                  "    ",
                  "    // With 500 max_tokens, context should be limited",
                  "    // Rough estimate: 1 token â‰ˆ 4 characters",
                  "    const estimatedTokens = data.short_term_context.length / 4;",
                  "    console.log(\"Estimated tokens in context:\", Math.round(estimatedTokens));",
                  "    ",
                  "    // Should not be significantly longer than requested",
                  "    pm.expect(estimatedTokens).to.be.below(700); // Some buffer",
                  "});",
                  "",
                  "console.log(\"âœ… Token limit respected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-context-002",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"session_id\": \"{{memory_test_session_id}}\",\n  \"max_tokens\": 500\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/context",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "context"
              ]
            },
            "description": "Tests memory context retrieval with reduced token limit. Verifies token budget is respected for context truncation."
          },
          "response": []
        },
        {
          "name": "Get Conversation History - Success",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-history-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Message history is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data).to.have.property('messages');",
                  "    pm.expect(data).to.have.property('total_count');",
                  "    ",
                  "    pm.expect(data.messages).to.be.an('array');",
                  "    pm.expect(data.total_count).to.eql(data.messages.length);",
                  "    ",
                  "    // Verificar que hay al menos 4 mensajes (2 user + 2 assistant)",
                  "    pm.expect(data.messages.length).to.be.at.least(4);",
                  "    ",
                  "    // Verificar que no hay mÃ¡s de los esperados (50 es el lÃ­mite)",
                  "    pm.expect(data.messages.length).to.be.at.most(50);",
                  "});",
                  "",
                  "pm.test(\"Message structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    if (data.messages.length > 0) {",
                  "        const msg = data.messages[0];",
                  "        pm.expect(msg).to.have.property('role');",
                  "        pm.expect(msg).to.have.property('content');",
                  "        pm.expect(msg).to.have.property('timestamp');",
                  "        pm.expect(msg).to.have.property('metadata');",
                  "        ",
                  "        // Validate role",
                  "        pm.expect(['user', 'assistant', 'system']).to.include(msg.role);",
                  "        ",
                  "        // Validate ISO timestamp format (flexible)",
                  "        const timestamp = new Date(msg.timestamp);",
                  "        pm.expect(timestamp.toString()).to.not.equal('Invalid Date');",
                  "        pm.expect(msg.timestamp).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/);",
                  "    }",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Conversation history retrieved\");",
                  "console.log(\"   Total messages:\", data.total_count);",
                  "",
                  "if (data.messages.length > 0) {",
                  "    console.log(\"   First message:\", data.messages[0].role, \"-\", data.messages[0].content.substring(0, 50) + \"...\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-history-001",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/history/{{memory_test_session_id}}?limit=50",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "history",
                "{{memory_test_session_id}}"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "50"
                }
              ]
            },
            "description": "Retrieves full conversation history with role, content, timestamp, and metadata for each message. Validates ISO datetime format and message structure."
          },
          "response": []
        },
        {
          "name": "Get Conversation History - With Limit",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-history-test-002",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"History respects limit parameter\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.messages).to.be.an('array');",
                  "    pm.expect(data.messages.length).to.be.at.most(2);",
                  "});",
                  "",
                  "console.log(\"âœ… History limit parameter working\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-history-002",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/history/{{memory_test_session_id}}?limit=2",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "history",
                "{{memory_test_session_id}}"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "2"
                }
              ]
            },
            "description": "Tests pagination with reduced limit. Ensures only requested number of messages are returned."
          },
          "response": []
        },
        {
          "name": "Get Memory Statistics - Success",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-stats-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Memory statistics are valid\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data).to.have.property('message_count');",
                  "    pm.expect(data).to.have.property('token_count');",
                  "    pm.expect(data).to.have.property('semantic_facts_count');",
                  "    pm.expect(data).to.have.property('profile_attributes_count');",
                  "    ",
                  "    pm.expect(data.message_count).to.be.a('number').and.at.least(1);",
                  "    pm.expect(data.token_count).to.be.a('number').and.at.least(0);",
                  "    pm.expect(data.semantic_facts_count).to.be.a('number').and.at.least(0);",
                  "    pm.expect(data.profile_attributes_count).to.be.a('number').and.at.least(0);",
                  "});",
                  "",
                  "pm.test(\"Timestamp fields are valid\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    if (data.oldest_message) {",
                  "        const oldestDate = new Date(data.oldest_message);",
                  "        pm.expect(oldestDate.toString()).to.not.equal('Invalid Date');",
                  "        pm.expect(data.oldest_message).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/);",
                  "    }",
                  "    ",
                  "    if (data.newest_message) {",
                  "        const newestDate = new Date(data.newest_message);",
                  "        pm.expect(newestDate.toString()).to.not.equal('Invalid Date');",
                  "        pm.expect(data.newest_message).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/);",
                  "    }",
                  "    ",
                  "    // If both exist, oldest should be before newest",
                  "    if (data.oldest_message && data.newest_message) {",
                  "        pm.expect(new Date(data.oldest_message)).to.be.at.most(new Date(data.newest_message));",
                  "    }",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Memory statistics retrieved\");",
                  "console.log(\"   Messages:\", data.message_count);",
                  "console.log(\"   Tokens:\", data.token_count);",
                  "console.log(\"   Semantic facts:\", data.semantic_facts_count);",
                  "console.log(\"   Profile attributes:\", data.profile_attributes_count);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-stats-001",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/stats/{{memory_test_session_id}}",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "stats",
                "{{memory_test_session_id}}"
              ]
            },
            "description": "Retrieves comprehensive memory usage statistics including message/token counts, semantic facts count, profile attributes, and conversation timestamps."
          },
          "response": []
        },
        {
          "name": "Search Semantic Memory - Success",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "mem-search-prereq-001",
                "exec": [
                  "// Check if Pinecone is configured",
                  "console.log(\"ðŸ” Testing semantic search (requires Pinecone configuration)\");",
                  "console.log(\"â„¹ï¸  If Pinecone is not configured, this test will fail with 500 error\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "mem-search-test-001",
                "exec": [
                  "// Check if request succeeded or failed due to missing Pinecone",
                  "const responseCode = pm.response.code;",
                  "",
                  "if (responseCode === 500) {",
                  "    // Pinecone not configured - expected failure",
                  "    const error = pm.response.json();",
                  "    ",
                  "    pm.test(\"Error indicates Pinecone configuration missing\", () => {",
                  "        pm.expect(error).to.have.property('detail');",
                  "        const detail = error.detail.toLowerCase();",
                  "        const hasPineconeError = detail.includes('pinecone') || detail.includes('memory service') || detail.includes('initialize');",
                  "        pm.expect(hasPineconeError).to.be.true;",
                  "    });",
                  "    ",
                  "    pm.collectionVariables.set(\"semantic_search_enabled\", \"false\");",
                  "    console.log(\"âš ï¸  Semantic search not available (Pinecone not configured)\");",
                  "    console.log(\"   This is expected if PINECONE_API_KEY is not set\");",
                  "    ",
                  "} else if (responseCode === 200) {",
                  "    // Success - Pinecone configured",
                  "    pm.test(\"Status code is 200\", () => {",
                  "        pm.response.to.have.status(200);",
                  "    });",
                  "    ",
                  "    pm.test(\"Semantic search results are valid\", () => {",
                  "        const data = pm.response.json();",
                  "        ",
                  "        pm.expect(data).to.have.property('query');",
                  "        pm.expect(data).to.have.property('results');",
                  "        pm.expect(data).to.have.property('total_results');",
                  "        ",
                  "        pm.expect(data.results).to.be.an('array');",
                  "        pm.expect(data.total_results).to.eql(data.results.length);",
                  "        ",
                  "        // Validate result structure if results exist",
                  "        if (data.results.length > 0) {",
                  "            const result = data.results[0];",
                  "            pm.expect(result).to.have.property('score');",
                  "            pm.expect(result).to.have.property('text');",
                  "            pm.expect(result.score).to.be.a('number').and.within(0, 1);",
                  "        }",
                  "    });",
                  "    ",
                  "    pm.collectionVariables.set(\"semantic_search_enabled\", \"true\");",
                  "    ",
                  "    const data = pm.response.json();",
                  "    console.log(\"âœ… Semantic search working\");",
                  "    console.log(\"   Results found:\", data.total_results);",
                  "    ",
                  "    if (data.results.length === 0) {",
                  "        console.log(\"â„¹ï¸  No results (semantic facts may not be extracted yet)\");",
                  "    }",
                  "} else {",
                  "    pm.test(\"Unexpected response code\", () => {",
                  "        pm.expect.fail(`Unexpected status code: ${responseCode}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-search-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"Python programming\",\n  \"top_k\": 3\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/search",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "search"
              ]
            },
            "description": "Searches semantic memory using vector similarity. Requires Pinecone configuration. If Pinecone is not configured, this will fail with 500 error indicating missing configuration. Sets semantic_search_enabled variable based on result."
          },
          "response": []
        },
        {
          "name": "Search Semantic Memory - With Session Filter",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "mem-search-prereq-002",
                "exec": [
                  "// Only run if semantic search is available",
                  "const searchEnabled = pm.collectionVariables.get(\"semantic_search_enabled\");",
                  "if (searchEnabled === \"false\") {",
                  "    console.log(\"â­ï¸  Skipping: Semantic search not available\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "mem-search-test-002",
                "exec": [
                  "const searchEnabled = pm.collectionVariables.get(\"semantic_search_enabled\");",
                  "",
                  "if (searchEnabled === \"false\") {",
                  "    pm.test(\"Skipped (Pinecone not configured)\", () => {",
                  "        pm.expect(true).to.be.true;",
                  "    });",
                  "    console.log(\"â­ï¸  Test skipped - semantic search not available\");",
                  "    return;",
                  "}",
                  "",
                  "if (pm.response.code === 200) {",
                  "    pm.test(\"Status code is 200\", () => {",
                  "        pm.response.to.have.status(200);",
                  "    });",
                  "    ",
                  "    pm.test(\"Search with session filter works\", () => {",
                  "        const data = pm.response.json();",
                  "        pm.expect(data).to.have.property('results');",
                  "        pm.expect(data.results).to.be.an('array');",
                  "        ",
                  "        // All results should be from the filtered session",
                  "        const sessionId = pm.collectionVariables.get(\"memory_test_session_id\");",
                  "        data.results.forEach(result => {",
                  "            if (result.session_id) {",
                  "                pm.expect(result.session_id).to.eql(sessionId);",
                  "            }",
                  "        });",
                  "    });",
                  "    ",
                  "    console.log(\"âœ… Session filter applied successfully\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-search-002",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"data science\",\n  \"session_id\": \"{{memory_test_session_id}}\",\n  \"top_k\": 5\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/search",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "search"
              ]
            },
            "description": "Tests semantic search with session filter. Only searches within specified session. Skipped if Pinecone not configured."
          },
          "response": []
        },
        {
          "name": "Memory - 422 Invalid Session ID (Empty)",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-error-test-001",
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error message indicates validation failure\", () => {",
                  "    const error = pm.response.json();",
                  "    pm.expect(error).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Empty session_id properly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-error-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"session_id\": \"\",\n  \"max_tokens\": 2000\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/context",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "context"
              ]
            },
            "description": "Tests validation error for empty session_id. Should return 422 validation error."
          },
          "response": []
        },
        {
          "name": "Memory - 422 Invalid Max Tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-error-test-002",
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error indicates max_tokens out of range\", () => {",
                  "    const error = pm.response.json();",
                  "    pm.expect(error).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Invalid max_tokens properly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-error-002",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"session_id\": \"{{memory_test_session_id}}\",\n  \"max_tokens\": 9000\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/memory/context",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "context"
              ]
            },
            "description": "Tests validation for max_tokens parameter. Valid range is 1-8000, so 9000 should be rejected with 422."
          },
          "response": []
        },
        {
          "name": "Memory - Non-existent Session (Edge Case)",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "mem-edge-test-001",
                "exec": [
                  "pm.test(\"Status code is 200 (not 404)\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Returns empty/default values gracefully\", () => {",
                  "    const data = pm.response.json();",
                  "    ",
                  "    pm.expect(data).to.have.property('session_id');",
                  "    pm.expect(data).to.have.property('messages');",
                  "    pm.expect(data.messages).to.be.an('array').and.to.be.empty;",
                  "    pm.expect(data.total_count).to.eql(0);",
                  "});",
                  "",
                  "console.log(\"âœ… Non-existent session handled gracefully (returns empty, not 404)\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "mem-edge-001",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/history/non-existent-session-12345?limit=50",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "history",
                "non-existent-session-12345"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "50"
                }
              ]
            },
            "description": "Tests edge case of querying non-existent session. Should return 200 with empty data, not 404 error. Demonstrates graceful degradation."
          },
          "response": []
        }
      ],
      "id": "8a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d",
      "description": "Tests for conversation memory management including short-term buffer, long-term extraction (semantic, episodic, profile, procedural), history retrieval, statistics, and semantic search. Requires chat messages from Section 3. Tests memory context, history retrieval, statistics, semantic search (with Pinecone), and cleanup. Includes database pre-flight check and graceful handling of optional Pinecone dependency."
    },
    {
      "name": "5. Session Management",
      "item": [
        {
          "name": "Session Reset - Success",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "session-reset-prereq-001",
                "exec": [
                  "// Ensure we have a session ID to work with",
                  "let sessionId = pm.collectionVariables.get(\"session_id\");",
                  "if (!sessionId) {",
                  "    sessionId = \"test-session-\" + Date.now();",
                  "    pm.collectionVariables.set(\"session_id\", sessionId);",
                  "}",
                  "",
                  "console.log(\"ðŸ”„ Resetting session:\", sessionId);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "session-reset-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has correct structure\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data).to.have.property('new_session_id');",
                  "    pm.expect(data).to.have.property('message');",
                  "});",
                  "",
                  "pm.test(\"Reset was successful\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.success).to.be.true;",
                  "});",
                  "",
                  "pm.test(\"New session ID is valid UUID\", () => {",
                  "    const data = pm.response.json();",
                  "    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;",
                  "    pm.expect(data.new_session_id).to.match(uuidRegex);",
                  "});",
                  "",
                  "pm.test(\"New session ID is different from old one\", () => {",
                  "    const data = pm.response.json();",
                  "    const oldSessionId = pm.collectionVariables.get(\"session_id\");",
                  "    pm.expect(data.new_session_id).to.not.equal(oldSessionId);",
                  "});",
                  "",
                  "pm.test(\"Message includes deletion count\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.message).to.include('messages');",
                  "});",
                  "",
                  "// Save new session ID for future tests",
                  "const data = pm.response.json();",
                  "pm.collectionVariables.set(\"session_id\", data.new_session_id);",
                  "pm.collectionVariables.set(\"session_reset_completed\", \"true\");",
                  "",
                  "console.log(\"âœ… Session reset successful\");",
                  "console.log(\"   - Old session:\", pm.request.body.raw ? JSON.parse(pm.request.body.raw).current_session_id : 'unknown');",
                  "console.log(\"   - New session:\", data.new_session_id);",
                  "console.log(\"   - Message:\", data.message);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "session-reset-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"current_session_id\": \"{{session_id}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset"
              ]
            },
            "description": "Resets the current session by clearing ALL chat history (short-term memory) from all sessions while preserving long-term memory and RAG documents. Generates a new session UUID."
          },
          "response": []
        },
        {
          "name": "Session Reset - Verify History Cleared",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "session-reset-prereq-002",
                "exec": [
                  "// Check if reset was completed",
                  "const resetCompleted = pm.collectionVariables.get(\"session_reset_completed\");",
                  "if (resetCompleted !== \"true\") {",
                  "    console.warn(\"âš ï¸  Session reset test should run before this test\");",
                  "}",
                  "",
                  "console.log(\"ðŸ” Verifying chat history was cleared\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "session-reset-test-002",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"History is empty after reset\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('messages');",
                  "    pm.expect(data.messages).to.be.an('array');",
                  "    pm.expect(data.messages).to.have.lengthOf(0);",
                  "});",
                  "",
                  "pm.test(\"Total messages is 0\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.total_count).to.equal(0);",
                  "});",
                  "",
                  "console.log(\"âœ… Verified: Chat history successfully cleared after reset\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "session-reset-002",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/history/{{session_id}}?limit=50",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "history",
                "{{session_id}}"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "50"
                }
              ]
            },
            "description": "Verifies that chat history is empty after session reset. This confirms the reset operation successfully deleted all messages."
          },
          "response": []
        },
        {
          "name": "Session Reset - Invalid Empty Session ID",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "session-reset-test-003",
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error response has detail\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Empty session_id properly rejected with 422\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "session-reset-003",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"current_session_id\": \"\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset"
              ]
            },
            "description": "Tests validation error for empty session_id. Should return 422 validation error."
          },
          "response": []
        },
        {
          "name": "Session Reset - Missing Session ID Field",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "session-reset-test-004",
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error response indicates missing field\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Missing current_session_id field properly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "session-reset-004",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset"
              ]
            },
            "description": "Tests that the current_session_id field is required. Should return 422 validation error."
          },
          "response": []
        }
      ],
      "id": "5a6b7c8d-9e0f-1a2b-3c4d-5e6f7a8b9c0d",
      "description": "Tests for session management including session reset. Session reset clears ALL chat history (short-term memory from all sessions) while preserving long-term memory and RAG documents."
    },
    {
      "name": "6. RAG - Setup",
      "item": [
        {
          "name": "Add Single Document",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response indicates success\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data.success).to.be.true;",
                  "});",
                  "",
                  "pm.test(\"Documents were added\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('documents_added');",
                  "    pm.expect(data.documents_added).to.be.above(0);",
                  "});",
                  "",
                  "// Track total documents added",
                  "const data = pm.response.json();",
                  "let totalDocs = pm.collectionVariables.get(\"documents_added\") || 0;",
                  "totalDocs += data.documents_added;",
                  "pm.collectionVariables.set(\"documents_added\", totalDocs);",
                  "",
                  "console.log(\"âœ… Added\", data.documents_added, \"document(s). Total:\", totalDocs);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "c64cbe59-7f95-4b5e-a0f9-4ff7806e5fef",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documents\": [\n    \"Python is a versatile programming language used for web development, data science, automation, and more. It emphasizes code readability and simplicity.\"\n  ],\n  \"namespace\": \"{{test_namespace}}\",\n  \"chunk_size\": 1000,\n  \"chunk_overlap\": 200\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/documents",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ]
            },
            "description": "Adds a single text document to the RAG system. This is the simplest way to add knowledge."
          },
          "response": []
        },
        {
          "name": "Add Multiple Documents from Fixtures",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Multiple documents added\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.success).to.be.true;",
                  "    pm.expect(data.documents_added).to.be.at.least(2);",
                  "});",
                  "",
                  "// Update total count",
                  "const data = pm.response.json();",
                  "let totalDocs = pm.collectionVariables.get(\"documents_added\") || 0;",
                  "totalDocs += data.documents_added;",
                  "pm.collectionVariables.set(\"documents_added\", totalDocs);",
                  "",
                  "console.log(\"âœ… Added\", data.documents_added, \"documents. Total:\", totalDocs);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Initialize document counter if not exists",
                  "if (!pm.collectionVariables.get(\"documents_added\")) {",
                  "    pm.collectionVariables.set(\"documents_added\", 0);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "7a87148d-b6f8-419d-b733-7a6216e18624",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documents\": [\n    \"Python Programming Best Practices\\n\\nPython is a high-level, interpreted programming language known for its simplicity and readability.\\n\\nKey Features:\\n- Dynamic typing\\n- Automatic memory management\\n- Comprehensive standard library\\n- Support for multiple programming paradigms\\n\\nBest Practices:\\n1. Follow PEP 8 style guide\\n2. Write clear, descriptive variable names\\n3. Use docstrings for documentation\\n4. Implement error handling with try-except blocks\\n5. Keep functions small and focused (Single Responsibility Principle)\\n\\nCommon Use Cases:\\n- Web development with frameworks like Django and FastAPI\\n- Data science and machine learning\\n- Automation and scripting\\n- System administration\",\n    \"# FastAPI Framework Overview\\n\\nFastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.7+.\\n\\n## Key Features\\n\\n- **Fast**: Very high performance, on par with NodeJS and Go\\n- **Fast to code**: Increase development speed by 200-300%\\n- **Fewer bugs**: Reduce human errors by about 40%\\n- **Intuitive**: Great editor support with auto-completion\\n- **Easy**: Designed to be easy to learn and use\\n- **Standards-based**: Based on OpenAPI and JSON Schema\\n\\n## Use Cases\\n\\n- REST APIs\\n- Microservices\\n- Real-time applications with WebSockets\\n- Machine Learning model serving\"\n  ],\n  \"namespace\": \"{{test_namespace}}\",\n  \"chunk_size\": 800,\n  \"chunk_overlap\": 150\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/documents",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ]
            },
            "description": "Adds multiple fixture documents to the RAG system. Content is sent directly as text, not file paths."
          },
          "response": []
        },
        {
          "name": "Add Directory (Initial Knowledge)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This test expects the server to have access to data/initial_knowledge/ directory",
                  "// If running locally, this directory exists in the project",
                  "// If directory is empty or not accessible, test will pass with 0 documents",
                  "",
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Directory endpoint works\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.success).to.be.true;",
                  "    // Directory might be empty - just check success",
                  "    pm.expect(data.documents_added).to.be.at.least(0);",
                  "});",
                  "",
                  "// Update total count",
                  "const data = pm.response.json();",
                  "let totalDocs = pm.collectionVariables.get(\"documents_added\") || 0;",
                  "totalDocs += data.documents_added;",
                  "pm.collectionVariables.set(\"documents_added\", totalDocs);",
                  "",
                  "if (data.documents_added > 0) {",
                  "    console.log(\"âœ… Added\", data.documents_added, \"documents from directory\");",
                  "} else {",
                  "    console.log(\"â„¹ï¸  Directory empty or not accessible - skipping\");",
                  "}",
                  "console.log(\"ðŸ“Š Total documents in RAG:\", totalDocs);",
                  "",
                  "// Mark RAG as ready for queries",
                  "pm.collectionVariables.set(\"rag_ready\", \"true\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "30295b92-120d-4fc5-a99e-fea0fde85455",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"directory\": \"data/initial_knowledge\",\n  \"namespace\": \"{{test_namespace}}\",\n  \"recursive\": true,\n  \"chunk_size\": 1000,\n  \"chunk_overlap\": 200\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/directory",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "directory"
              ]
            },
            "description": "Adds documents from a directory on the server. Uses 'data/initial_knowledge' which should be accessible by the backend. For testing with fixtures, use the 'Add Multiple Documents from Fixtures' endpoint instead."
          },
          "response": []
        }
      ],
      "id": "a7ba013d-c42e-44b1-aa79-a4ebf2f147c1",
      "description": "Setup phase for RAG tests. These requests add documents to the knowledge base that will be queried in the next section."
    },
    {
      "name": "7. RAG - Query Operations",
      "item": [
        {
          "name": "Query - Basic",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Check if RAG is ready",
                  "const ragReady = pm.collectionVariables.get(\"rag_ready\");",
                  "const docsAdded = pm.collectionVariables.get(\"documents_added\");",
                  "",
                  "if (ragReady !== \"true\" || !docsAdded || docsAdded === 0) {",
                  "    console.error(\"âŒ RAG not ready. Run '4. RAG - Setup' first.\");",
                  "    console.log(\"Documents added:\", docsAdded);",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Query successful\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data.success).to.be.true;",
                  "});",
                  "",
                  "pm.test(\"Response contains answer\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('response');",
                  "    pm.expect(data.response).to.be.a('string').and.not.empty;",
                  "});",
                  "",
                  "pm.test(\"Sources are provided\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('sources');",
                  "    pm.expect(data.sources).to.be.an('array');",
                  "    pm.expect(data.sources.length).to.be.above(0);",
                  "});",
                  "",
                  "pm.test(\"Sources have required metadata\", () => {",
                  "    const data = pm.response.json();",
                  "    const firstSource = data.sources[0];",
                  "    pm.expect(firstSource).to.have.property('content_preview');",
                  "    pm.expect(firstSource).to.have.property('source');",
                  "    pm.expect(firstSource).to.have.property('chunk');",
                  "    pm.expect(firstSource).to.have.property('created_at');",
                  "    pm.expect(firstSource).to.have.property('score');",
                  "    pm.expect(firstSource.score).to.be.a('number');",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Query successful\");",
                  "console.log(\"Response:\", data.response.substring(0, 100) + \"...\");",
                  "console.log(\"Sources found:\", data.sources.length);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "7b50dec2-c91c-435c-b921-fc1c0eb9d7b0",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"What are the main features of Python?\",\n  \"top_k\": 3,\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Performs a basic RAG query. Retrieves relevant documents and generates an answer based on them."
          },
          "response": []
        },
        {
          "name": "Query - About FastAPI",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response mentions FastAPI\", () => {",
                  "    const data = pm.response.json();",
                  "    const response = data.response.toLowerCase();",
                  "    pm.expect(response).to.include('fastapi');",
                  "});",
                  "",
                  "pm.test(\"Retrieved relevant sources\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.sources.length).to.be.above(0);",
                  "    // At least one source should mention FastAPI",
                  "    const hasFastAPI = data.sources.some(s => ",
                  "        s.content_preview.toLowerCase().includes('fastapi')",
                  "    );",
                  "    pm.expect(hasFastAPI).to.be.true;",
                  "});",
                  "",
                  "console.log(\"âœ… FastAPI query successful\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "9596cb61-43e2-404d-be0b-1801beff0386",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"What is FastAPI and what are its key features?\",\n  \"top_k\": 5,\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Tests RAG retrieval for specific topic (FastAPI) from fixture documents."
          },
          "response": []
        },
        {
          "name": "Query - About SOLID Principles",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response about SOLID principles\", () => {",
                  "    const data = pm.response.json();",
                  "    const response = data.response.toLowerCase();",
                  "    // Should mention at least some SOLID principles",
                  "    const mentionsSolid = response.includes('solid') || ",
                  "                         response.includes('single responsibility') ||",
                  "                         response.includes('open closed') ||",
                  "                         response.includes('liskov');",
                  "    pm.expect(mentionsSolid).to.be.true;",
                  "});",
                  "",
                  "console.log(\"âœ… SOLID principles query successful\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "609d72fc-1413-447c-b19d-96d8bf851bb7",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"Explain the SOLID principles in software engineering.\",\n  \"top_k\": 5,\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Tests retrieval of SOLID principles documentation from fixture sample_doc_3.txt."
          },
          "response": []
        },
        {
          "name": "Query - With High top_k",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Returns multiple sources\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.sources.length).to.be.above(0);",
                  "    // May not reach 10 if corpus is small, but should try",
                  "});",
                  "",
                  "pm.test(\"Sources are sorted by relevance\", () => {",
                  "    const data = pm.response.json();",
                  "    if (data.sources.length > 1) {",
                  "        // Scores should be descending (higher score = more similar)",
                  "        let sortErrors = [];",
                  "        for (let i = 0; i < data.sources.length - 1; i++) {",
                  "            const current = data.sources[i].score || 0;",
                  "            const next = data.sources[i + 1].score || 0;",
                  "            if (current < next) {",
                  "                sortErrors.push(`Position ${i}: ${current} < Position ${i+1}: ${next}`);",
                  "            }",
                  "        }",
                  "        ",
                  "        if (sortErrors.length > 0) {",
                  "            console.log(\"âš ï¸  Sort order violations found:\");",
                  "            sortErrors.forEach(err => console.log(`   ${err}`));",
                  "            console.log(\"All scores:\", data.sources.map((s, i) => `[${i}]: ${s.score}`).join(\", \"));",
                  "        }",
                  "        ",
                  "        pm.expect(sortErrors.length, `Found ${sortErrors.length} sort violations: ${sortErrors.join(\"; \")}`).to.equal(0);",
                  "    }",
                  "});",
                  "",
                  "console.log(\"âœ… High top_k query successful\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "9b7e45aa-cac3-4aa5-b3fd-282061275ef0",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"programming best practices\",\n  \"top_k\": 10,\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Tests retrieval with high top_k value to get more context documents."
          },
          "response": []
        },
        {
          "name": "Query - Empty Query Error",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (Validation Error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Error detail provided\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Empty query correctly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "4de704f4-aa0d-46e6-a89b-9add09f6495d",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"\",\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Tests that empty queries are properly rejected."
          },
          "response": []
        }
      ],
      "id": "2ab941ba-a7e9-45e9-a157-0cb9481590e3",
      "description": "Query operations that retrieve and synthesize information from the RAG knowledge base. Depends on documents being added in section 9."
    },
    {
      "name": "7b. RAG - Listing Operations",
      "item": [
        {
          "name": "List Namespaces - Success",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has namespaces array\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('namespaces');",
                  "    pm.expect(data.namespaces).to.be.an('array');",
                  "});",
                  "",
                  "pm.test(\"Namespace structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    if (data.namespaces.length > 0) {",
                  "        const ns = data.namespaces[0];",
                  "        pm.expect(ns).to.have.property('name');",
                  "        pm.expect(ns).to.have.property('document_count');",
                  "        pm.expect(ns).to.have.property('total_chunks');",
                  "        pm.expect(ns).to.have.property('last_updated');",
                  "        pm.expect(ns.document_count).to.be.a('number');",
                  "        pm.expect(ns.total_chunks).to.be.a('number');",
                  "    }",
                  "});",
                  "",
                  "pm.test(\"Test namespace exists\", () => {",
                  "    const data = pm.response.json();",
                  "    const testNamespace = pm.collectionVariables.get(\"test_namespace\");",
                  "    const hasTestNamespace = data.namespaces.some(ns => ns.name === testNamespace);",
                  "    if (pm.collectionVariables.get(\"documents_added\") > 0) {",
                  "        pm.expect(hasTestNamespace).to.be.true;",
                  "    }",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Listed\", data.namespaces.length, \"namespace(s)\");",
                  "data.namespaces.forEach(ns => {",
                  "    console.log(`â„¹ï¸  ${ns.name}: ${ns.document_count} docs, ${ns.total_chunks} chunks`);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "list-namespaces-success",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/namespaces",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "namespaces"
              ]
            },
            "description": "Lists all available RAG namespaces with their document counts, chunk counts, and last update timestamps."
          },
          "response": []
        },
        {
          "name": "List Documents - All",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has documents array\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('documents');",
                  "    pm.expect(data.documents).to.be.an('array');",
                  "});",
                  "",
                  "pm.test(\"Response has pagination fields\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('total_count');",
                  "    pm.expect(data).to.have.property('limit');",
                  "    pm.expect(data).to.have.property('offset');",
                  "    pm.expect(data).to.have.property('has_more');",
                  "    pm.expect(data.total_count).to.be.a('number');",
                  "    pm.expect(data.limit).to.be.a('number');",
                  "    pm.expect(data.offset).to.be.a('number');",
                  "    pm.expect(data.has_more).to.be.a('boolean');",
                  "});",
                  "",
                  "pm.test(\"Document structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    if (data.documents.length > 0) {",
                  "        const doc = data.documents[0];",
                  "        pm.expect(doc).to.have.property('id');",
                  "        pm.expect(doc).to.have.property('filename');",
                  "        pm.expect(doc).to.have.property('namespace');",
                  "        pm.expect(doc).to.have.property('chunk_count');",
                  "        pm.expect(doc).to.have.property('uploaded_at');",
                  "        pm.expect(doc).to.have.property('file_size');",
                  "        pm.expect(doc.chunk_count).to.be.a('number');",
                  "    }",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Listed\", data.documents.length, \"document(s) out of\", data.total_count, \"total\");",
                  "console.log(\"â„¹ï¸  Pagination: limit=\", data.limit, \"offset=\", data.offset, \"has_more=\", data.has_more);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "list-documents-all",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/documents?limit=100&offset=0",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "100"
                },
                {
                  "key": "offset",
                  "value": "0"
                }
              ]
            },
            "description": "Lists all documents across all namespaces with pagination support."
          },
          "response": []
        },
        {
          "name": "List Documents - By Namespace",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"All documents belong to requested namespace\", () => {",
                  "    const data = pm.response.json();",
                  "    const requestedNamespace = pm.collectionVariables.get(\"test_namespace\");",
                  "    data.documents.forEach(doc => {",
                  "        pm.expect(doc.namespace).to.eql(requestedNamespace);",
                  "    });",
                  "});",
                  "",
                  "pm.test(\"Documents match added count\", () => {",
                  "    const data = pm.response.json();",
                  "    const docsAdded = pm.collectionVariables.get(\"documents_added\") || 0;",
                  "    if (docsAdded > 0) {",
                  "        pm.expect(data.documents.length).to.be.above(0);",
                  "    }",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "const namespace = pm.collectionVariables.get(\"test_namespace\");",
                  "console.log(`âœ… Listed ${data.documents.length} document(s) in namespace '${namespace}'`);",
                  "data.documents.forEach(doc => {",
                  "    console.log(`â„¹ï¸  ${doc.filename}: ${doc.chunk_count} chunks, ${doc.file_size} bytes`);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "list-documents-by-namespace",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/documents?namespace={{test_namespace}}&limit=50",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ],
              "query": [
                {
                  "key": "namespace",
                  "value": "{{test_namespace}}"
                },
                {
                  "key": "limit",
                  "value": "50"
                }
              ]
            },
            "description": "Lists documents filtered by a specific namespace."
          },
          "response": []
        },
        {
          "name": "List Documents - Pagination",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Pagination parameters applied\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.limit).to.eql(10);",
                  "    pm.expect(data.offset).to.eql(0);",
                  "});",
                  "",
                  "pm.test(\"has_more flag is boolean\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(typeof data.has_more).to.eql('boolean');",
                  "});",
                  "",
                  "pm.test(\"Documents length <= limit\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.documents.length).to.be.at.most(data.limit);",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"âœ… Pagination test: got\", data.documents.length, \"docs (limit=10, offset=0)\");",
                  "console.log(\"â„¹ï¸  Total available:\", data.total_count, \"has_more:\", data.has_more);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "list-documents-pagination",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/documents?limit=10&offset=0",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "10"
                },
                {
                  "key": "offset",
                  "value": "0"
                }
              ]
            },
            "description": "Tests pagination with small limit to verify proper pagination behavior."
          },
          "response": []
        },
        {
          "name": "List Documents - Invalid Limit",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 400\", () => {",
                  "    pm.response.to.have.status(400);",
                  "});",
                  "",
                  "pm.test(\"Error message mentions limit\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "    pm.expect(data.detail.toLowerCase()).to.include('limit');",
                  "});",
                  "",
                  "console.log(\"âœ… Invalid limit properly rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "list-documents-invalid-limit",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/documents?limit=2000",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "documents"
              ],
              "query": [
                {
                  "key": "limit",
                  "value": "2000"
                }
              ]
            },
            "description": "Tests that invalid limit values (>1000) are properly rejected with 400 error."
          },
          "response": []
        }
      ],
      "id": "rag-listing-operations",
      "description": "Tests for RAG listing operations including namespaces and documents with pagination. These tests verify the ability to browse and inspect the RAG knowledge base. Depends on documents being added in section 6."
    },
    {
      "name": "8. Error Scenarios",
      "item": [
        {
          "name": "404 - Invalid Endpoint",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 404\", () => {",
                  "    pm.response.to.have.status(404);",
                  "});",
                  "",
                  "pm.test(\"Error response structure\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… 404 error handled correctly\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "4421e96e-e63a-4967-8cb9-8603cc689fd2",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/nonexistent/endpoint",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "nonexistent",
                "endpoint"
              ]
            },
            "description": "Tests 404 error handling for non-existent endpoints."
          },
          "response": []
        },
        {
          "name": "400 - Malformed JSON",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 400 or 422\", () => {",
                  "    const status = pm.response.code;",
                  "    pm.expect([400, 422]).to.include(status);",
                  "});",
                  "",
                  "console.log(\"âœ… Malformed JSON rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "c843f63a-5ea2-4441-b872-a178e8333a46",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"prompt\": \"Test\",\n  invalid json here\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Tests error handling for malformed JSON payloads."
          },
          "response": []
        },
        {
          "name": "422 - Missing Required Field",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Validation error detail provided\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "    pm.expect(data.detail).to.be.an('array');",
                  "});",
                  "",
                  "console.log(\"âœ… Missing required field rejected\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "99686fa8-f9ca-4477-b31d-6e054e8eb6ee",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"temperature\": 0.7\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/generate",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "generate"
              ]
            },
            "description": "Tests Pydantic validation when required 'prompt' field is missing."
          },
          "response": []
        },
        {
          "name": "422 - Invalid Parameter Type",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "pm.test(\"Type validation error\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('detail');",
                  "});",
                  "",
                  "console.log(\"âœ… Type validation working correctly\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "ac8a6702-1a83-46e3-b199-dd132d9afd0b",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"query\": \"test\",\n  \"top_k\": \"not_a_number\",\n  \"namespace\": \"{{test_namespace}}\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/llm/rag/query",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "query"
              ]
            },
            "description": "Tests type validation when top_k is provided as string instead of integer."
          },
          "response": []
        },
        {
          "name": "System Reset - Invalid Confirmation",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 400\", () => {",
                  "    pm.response.to.have.status(400);",
                  "});",
                  "",
                  "pm.test(\"Error message is clear\", () => {",
                  "    const response = pm.response.json();",
                  "    pm.expect(response).to.have.property('detail');",
                  "    pm.expect(response.detail).to.include('confirmation');",
                  "    pm.expect(response.detail).to.include('DELETE');",
                  "});",
                  "",
                  "console.log(\"âœ… System reset properly rejects invalid confirmation\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "error-reset-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"confirmation\": \"WRONG\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset-all",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset-all"
              ]
            },
            "description": "Tests that system reset rejects invalid confirmation strings. Must be exactly 'DELETE' to proceed."
          },
          "response": []
        },
        {
          "name": "System Reset - Missing Confirmation",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 422 (validation error)\", () => {",
                  "    pm.response.to.have.status(422);",
                  "});",
                  "",
                  "console.log(\"âœ… System reset properly rejects missing confirmation\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "error-reset-002",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset-all",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset-all"
              ]
            },
            "description": "Tests that system reset requires confirmation field in request body."
          },
          "response": []
        }
      ],
      "id": "f2754660-9c74-42a8-9d91-99a3e66ddc54",
      "description": "Tests various error scenarios to ensure proper error handling and validation."
    },
    {
      "name": "9. Cleanup",
      "item": [
        {
          "name": "Clear Memory Session",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "cleanup-mem-prereq-001",
                "exec": [
                  "const sessionId = pm.collectionVariables.get(\"memory_test_session_id\");",
                  "console.log(\"ðŸ§¹ Cleaning up memory session:\", sessionId);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "cleanup-mem-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Cleanup successful\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data.success).to.be.true;",
                  "    pm.expect(data).to.have.property('message');",
                  "});",
                  "",
                  "console.log(\"âœ… Memory session cleared\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "cleanup-mem-001",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/{{memory_test_session_id}}",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "{{memory_test_session_id}}"
              ]
            },
            "description": "Deletes all memory data for the test session. First step of cleanup process."
          },
          "response": []
        },
        {
          "name": "Verify Memory Cleared",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "cleanup-mem-verify-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Memory is empty after cleanup\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.messages).to.be.an('array').and.to.be.empty;",
                  "    pm.expect(data.total_count).to.eql(0);",
                  "});",
                  "",
                  "console.log(\"âœ… Memory cleanup verified - session is empty\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "cleanup-mem-verify-001",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/memory/history/{{memory_test_session_id}}",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "memory",
                "history",
                "{{memory_test_session_id}}"
              ]
            },
            "description": "Verifies that memory was actually cleared by checking conversation history is empty."
          },
          "response": []
        },
        {
          "name": "Get RAG Namespace Stats Before Cleanup",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Namespace stats structure is valid\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data).to.have.property('namespace');",
                  "    pm.expect(data).to.have.property('vector_count');",
                  "    pm.expect(data).to.have.property('dimension');",
                  "    pm.expect(data).to.have.property('exists');",
                  "});",
                  "",
                  "pm.test(\"Namespace exists and has vectors\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.success).to.be.true;",
                  "    pm.expect(data.exists).to.be.true;",
                  "    pm.expect(data.vector_count).to.be.above(0);",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "const totalDocs = pm.collectionVariables.get(\"documents_added\");",
                  "const memMessages = pm.collectionVariables.get(\"memory_messages_added\");",
                  "",
                  "console.log(\"ðŸ“Š Pre-cleanup verification:\");",
                  "console.log(\"   - Namespace:\", data.namespace);",
                  "console.log(\"   - Vectors in Pinecone:\", data.vector_count);",
                  "console.log(\"   - Vector dimension:\", data.dimension);",
                  "console.log(\"   - Documents added (tracked):\", totalDocs);",
                  "console.log(\"   - Memory messages:\", memMessages);",
                  "console.log(\"ðŸ§¹ Starting namespace cleanup...\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "3056e5aa-c876-4b14-85a6-80002fd5339b",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/namespace/{{test_namespace}}/stats",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "namespace",
                "{{test_namespace}}",
                "stats"
              ]
            },
            "description": "Retrieves namespace statistics from Pinecone before cleanup. Verifies that documents exist and shows actual vector count stored in the vector database."
          },
          "response": []
        },
        {
          "name": "Clean Up - Delete Test Namespace",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// Test successful namespace deletion",
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has correct structure\", () => {",
                  "    const response = pm.response.json();",
                  "    pm.expect(response).to.have.property(\"success\");",
                  "    pm.expect(response).to.have.property(\"namespace\");",
                  "    pm.expect(response).to.have.property(\"message\");",
                  "});",
                  "",
                  "pm.test(\"Deletion was successful\", () => {",
                  "    const response = pm.response.json();",
                  "    pm.expect(response.success).to.be.true;",
                  "    const expectedNamespace = pm.collectionVariables.get(\"test_namespace\") || pm.environment.get(\"test_namespace\");",
                  "    pm.expect(response.namespace).to.eql(expectedNamespace);",
                  "});",
                  "",
                  "// Reset collection variables",
                  "pm.collectionVariables.set(\"documents_added\", \"0\");",
                  "pm.collectionVariables.set(\"rag_ready\", \"false\");",
                  "pm.collectionVariables.set(\"memory_ready\", \"false\");",
                  "pm.collectionVariables.set(\"memory_messages_added\", \"0\");",
                  "pm.collectionVariables.set(\"semantic_search_enabled\", \"unknown\");",
                  "pm.collectionVariables.unset(\"session_id\");",
                  "pm.collectionVariables.unset(\"memory_test_session_id\");",
                  "pm.collectionVariables.unset(\"last_llm_response\");",
                  "",
                  "console.log(\"âœ… Collection variables reset\");",
                  "console.log(\"ðŸ§¹ Test cleanup complete\");",
                  "console.log(\"   - Memory session cleared\");",
                  "const cleanedNamespace = pm.collectionVariables.get(\"test_namespace\") || pm.environment.get(\"test_namespace\");",
                  "console.log(\"   - RAG namespace deleted:\", cleanedNamespace);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "69537a78-9661-4fe8-8d0c-1932364ebb30",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{base_url}}/llm/rag/namespace/{{test_namespace}}",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "llm",
                "rag",
                "namespace",
                "{{test_namespace}}"
              ]
            },
            "description": "Deletes the test namespace from Pinecone, removing all documents and vectors associated with test data. This ensures clean test runs and prevents data pollution."
          },
          "response": []
        },
        {
          "name": "Final System Reset - Complete Cleanup",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "cleanup-reset-prereq-001",
                "exec": [
                  "console.log(\"ðŸ§¹ FINAL CLEANUP: Complete System Reset\");",
                  "console.log(\"   This will DELETE ALL test data:\");",
                  "console.log(\"   - All conversation history\");",
                  "console.log(\"   - All memory (semantic, episodic, profile, procedural)\");",
                  "console.log(\"   - All RAG documents and vectors\");",
                  "console.log(\"   - All session configurations\");",
                  "console.log(\"\");",
                  "console.log(\"ðŸ’¡ This ensures a clean state for next test run.\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "cleanup-reset-test-001",
                "exec": [
                  "pm.test(\"Status code is 200\", () => {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has correct structure\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data).to.have.property('success');",
                  "    pm.expect(data).to.have.property('message');",
                  "    pm.expect(data).to.have.property('deleted');",
                  "});",
                  "",
                  "pm.test(\"Reset was successful\", () => {",
                  "    const data = pm.response.json();",
                  "    pm.expect(data.success).to.be.true;",
                  "    pm.expect(data.message).to.include('deleted');",
                  "});",
                  "",
                  "pm.test(\"Deletion counts are present\", () => {",
                  "    const data = pm.response.json();",
                  "    const deleted = data.deleted;",
                  "    pm.expect(deleted).to.have.property('sessions');",
                  "    pm.expect(deleted).to.have.property('memory_entries');",
                  "    pm.expect(deleted).to.have.property('rag_documents');",
                  "    pm.expect(deleted).to.have.property('vector_count');",
                  "    ",
                  "    // All should be numbers",
                  "    pm.expect(deleted.sessions).to.be.a('number');",
                  "    pm.expect(deleted.memory_entries).to.be.a('number');",
                  "    pm.expect(deleted.rag_documents).to.be.a('number');",
                  "    pm.expect(deleted.vector_count).to.be.a('number');",
                  "});",
                  "",
                  "const data = pm.response.json();",
                  "console.log(\"ðŸ’¥ NUCLEAR RESET EXECUTED\");",
                  "console.log(\"   Deletion counts:\");",
                  "console.log(\"   - Sessions:\", data.deleted.sessions);",
                  "console.log(\"   - Memory entries:\", data.deleted.memory_entries);",
                  "console.log(\"   - RAG documents:\", data.deleted.rag_documents);",
                  "console.log(\"   - Vector count:\", data.deleted.vector_count);",
                  "console.log(\"âœ… System restored to initial state\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "cleanup-reset-001",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"confirmation\": \"DELETE\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/session/reset-all",
              "host": [
                "{{base_url}}"
              ],
              "path": [
                "session",
                "reset-all"
              ]
            },
            "description": "ðŸ§¹ FINAL CLEANUP STEP ðŸ§¹\n\nExecutes complete system reset to ensure clean state for next test run.\n\nDeletes ALL data from the system including:\n- All conversation history from all sessions\n- All memory (semantic, episodic, profile, procedural)\n- All RAG documents and vectors from Pinecone\n- All session configurations\n- All MPC instances\n\nâœ… This runs automatically at the end of every test suite to prevent data pollution and ensure repeatable tests."
          },
          "response": []
        }
      ],
      "id": "1e7af483-3bbe-4f5d-912d-29706c89df84",
      "description": "Cleanup operations to remove test data after test execution. Cleans up memory sessions and RAG namespaces. Ensures tests can be run repeatedly without data pollution."
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "id": "e488daec-8ffe-4741-9f96-af1a9077d4f1",
        "type": "text/javascript",
        "exec": [
          "// Global pre-request script",
          "// Runs before every request",
          "",
          "// Log current timestamp",
          "const timestamp = new Date().toISOString();",
          "pm.collectionVariables.set(\"test_timestamp\", timestamp);",
          "",
          "// Validate environment is set",
          "const baseUrl = pm.environment.get(\"base_url\");",
          "if (!baseUrl) {",
          "    console.warn(\"âš ï¸  No base_url set in environment. Using collection default.\");",
          "}"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "id": "3ec1fd15-24bb-44ad-9a6b-31439ab563d1",
        "type": "text/javascript",
        "exec": [
          "// Global test script",
          "// Runs after every request",
          "",
          "// Log response time",
          "const responseTime = pm.response.responseTime;",
          "console.log(\"â±ï¸  Response time:\", responseTime, \"ms\");",
          "",
          "// Warn on slow responses",
          "if (responseTime > 5000) {",
          "    console.warn(\"âš ï¸  Slow response (>5s)\");",
          "}"
        ]
      }
    }
  ],
  "variable": [
    {
      "id": "1889148f-5754-497e-a5c0-965c9a2270e4",
      "key": "documents_added",
      "value": "0"
    },
    {
      "id": "00757f94-bb88-4af2-9ae3-e259e3a3a119",
      "key": "test_timestamp",
      "value": ""
    },
    {
      "id": "1085da78-e88e-42c6-94a7-1d12f41ea63d",
      "key": "rag_ready",
      "value": "false"
    },
    {
      "id": "5acd8878-49ac-4d54-b5bc-026d9233c5cb",
      "key": "base_url",
      "value": "http://localhost:8000",
      "type": "default"
    },
    {
      "id": "876b08ff-6b44-4c78-a9eb-d0bf8a32032c",
      "key": "memory_messages_added",
      "value": ""
    },
    {
      "id": "5683a16b-f1cc-4194-bcc8-3bfb03ab0c47",
      "key": "memory_ready",
      "value": ""
    },
    {
      "id": "979a06cc-f259-4592-a734-71cc8004cb87",
      "key": "semantic_search_enabled",
      "value": ""
    },
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "key": "test_namespace",
      "value": "test-namespace",
      "type": "default"
    },
    {
      "id": "b2c3d4e5-f6a7-8901-bcde-f12345678901",
      "key": "session_id",
      "value": ""
    },
    {
      "id": "c3d4e5f6-a7b8-9012-cdef-012345678902",
      "key": "memory_test_session_id",
      "value": ""
    }
  ]
}